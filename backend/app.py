# backend/app.py
import os, uuid, traceback, joblib, json
from fastapi import FastAPI, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, FileResponse

from backend.ocr_parser import parse_bill_image
from backend.analyzer import detect_anomaly, format_appliance_percentages
from backend.voice_reply import generate_tamil_reply
from backend.tangedco_complaint import generate_tangedco_complaint

app = FastAPI(title="WhatAmp MVP API")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# Ensure data dirs
os.makedirs("data/uploads", exist_ok=True)
os.makedirs("data/outputs", exist_ok=True)

# Load ML model + metrics
MODEL_PATH = "backend/models/appliance_model.joblib"
METRICS_PATH = "backend/models/metrics.json"

model, metrics = None, {}
if os.path.exists(MODEL_PATH):
    try:
        model = joblib.load(MODEL_PATH)
        print("✅ Loaded ML model.")
    except Exception as e:
        print("⚠️ Failed to load model:", e)

if os.path.exists(METRICS_PATH):
    try:
        with open(METRICS_PATH, "r") as f:
            metrics = json.load(f)
        print("✅ Loaded model metrics.")
    except Exception as e:
        print("⚠️ Failed to load metrics:", e)


@app.get("/health")
def health():
    return {"status": "ok"}


@app.post("/upload")
async def upload_bill(file: UploadFile = File(...), lang: str = "eng"):
    uid = str(uuid.uuid4())[:8]
    try:
        # -------------------------------
        # 1. Save uploaded file
        # -------------------------------
        fname = f"{uid}_{file.filename}"
        save_path = os.path.join("data/uploads", fname)
        with open(save_path, "wb") as f:
            f.write(await file.read())
        print(f"[DEBUG] Uploaded file saved: {save_path}")

        # -------------------------------
        # 2. OCR + parse
        # -------------------------------
        try:
            parsed = parse_bill_image(save_path, lang="eng")
            print(f"[DEBUG] Parsed: {parsed}")
        except Exception as e:
            print("[ERROR] OCR failed:", e)
            parsed = {"raw_text": "", "consumer_no": None, "units": None, "amount": None}

        # -------------------------------
        # 3. Units + anomaly detection
        # -------------------------------
        units = parsed.get("units")
        if not units and parsed.get("cur_read") and parsed.get("prev_read"):
            try:
                units = str(int(parsed["cur_read"]) - int(parsed["prev_read"]))
            except Exception as e:
                print("[WARN] Unit calculation failed:", e)
                units = None

        anomaly = detect_anomaly(units, baseline=200)
        total_kwh = float(units) if units else 200.0
        print(f"[DEBUG] Units={units}, Anomaly={anomaly}")

        # -------------------------------
        # 4. Appliance breakdown
        # -------------------------------
        appl_preds = {}
        if model is not None:
            try:
                import pandas as pd
                X = pd.DataFrame([[total_kwh, 1, 3]],
                                 columns=["total", "month", "household_size"])
                preds = model.predict(X)[0]
                names = ["fan", "ac", "fridge", "lights", "geyser"]
                appl_preds = dict(zip(names, [float(round(x, 1)) for x in preds]))
                print("[DEBUG] Model predictions:", appl_preds)
            except Exception as e:
                print("[WARN] Model inference failed:", e)

        if not appl_preds:
            appl_preds = {
                "fan": round(total_kwh * 0.25, 1),
                "ac": round(total_kwh * 0.40, 1),
                "fridge": round(total_kwh * 0.12, 1),
                "lights": round(total_kwh * 0.13, 1),
                "geyser": round(total_kwh * 0.10, 1),
            }
            print("[DEBUG] Using fallback appliance breakdown")

        appl_list = format_appliance_percentages(appl_preds)

        # -------------------------------
        # 5. Complaint PDF (safe fallback)
        # -------------------------------
        pdf_path = os.path.join("data/outputs", f"{uid}_cgrf_complaint.pdf")
        try:
            attachments = [save_path]
            generate_tangedco_complaint(
                parsed,
                anomaly.get("reason", "unknown"),
                extra_notes="Generated by WhatAmp",
                attachments=attachments,
                outpath=pdf_path,
            )
            print(f"[DEBUG] Complaint PDF generated: {pdf_path}")
        except Exception as e:
            print("[ERROR] Complaint PDF generation failed:", e)
            # Write a dummy PDF so link is valid
            with open(pdf_path, "wb") as f:
                f.write(b"%PDF-1.4\n% Dummy PDF\n")
            print("[DEBUG] Dummy PDF written.")

        # -------------------------------
        # 6. Tamil TTS (safe fallback)
        # -------------------------------
        tts_path = os.path.join("data/outputs", f"{uid}_reply.mp3")
        try:
            summary_text = f"உங்கள் பில்: {anomaly.get('reason','அறியப்படவில்லை')}. PDF ஐ பதிவிறக்கம் செய்து புகார் செய்யவும்."
            generate_tamil_reply(summary_text, tts_path)
            print(f"[DEBUG] Audio reply generated: {tts_path}")
        except Exception as e:
            print("[ERROR] TTS generation failed:", e)
            with open(tts_path, "wb") as f:
                f.write(b"")  # empty placeholder
            print("[DEBUG] Dummy MP3 written.")

        # -------------------------------
        # 7. Final response
        # -------------------------------
        return {
            "status": "ok",
            "parsed": parsed,
            "units": units,
            "anomaly": anomaly,
            "appliance_estimates_kwh": appl_preds,
            "appliance_estimates_percent": appl_list,
            "complaint_pdf": f"/download/{os.path.basename(pdf_path)}",
            "tamil_audio": f"/download/{os.path.basename(tts_path)}",
            "model_metrics": metrics,
        }

    except Exception as e:
        traceback.print_exc()
        return JSONResponse({"status": "error", "detail": str(e)}, status_code=500)


@app.get("/download/{filename}")
def download_file(filename: str):
    path = os.path.join("data/outputs", filename)
    if not os.path.exists(path):
        return JSONResponse({"error": "file-not-found"}, status_code=404)
    return FileResponse(path, media_type="application/octet-stream", filename=filename)
